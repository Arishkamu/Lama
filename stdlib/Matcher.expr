-- (C) Dmitry Boulytchev, St. Petersburg State University, JetBrains Research, 2020
-- Matcher: simple string matching library.

-- Create a regular expression representation.
-- Arguments:
--    r    --- a string representation for regular expression (as per GNU regexp)
--    name --- a string describing the meaning of the expression in free form
--             (e.g. "identifier", "string constant", etc.), used for error
--             reporting
fun createRegexp (r, name) {
  [regexp (r), name]
}

-- Create an immutable matcher.
-- Arguments:
--    buf --- a string to match in
--    pos --- an integer beginning position to match from
--    line, col --- line and column numbers
-- This function is internal, do not use it directly.
-- To initially create a matcher use initMatcher function (see below).
fun matcherCreate (buf, pos, line, col) {
  -- Shows a matcher in a readable form
  fun show () {
    sprintf ("buf : %-40s\npos : %d\nline: %d\ncol : %d\n", buf, pos, line, col)
  }

  -- Calculates the number of remaining unmatched characters in the buffer
  fun rest () {
    buf.length - pos
  }

  -- Moves the position pointer on given number of characters.
  fun shift (n) {
    local i, l = line, c = col;

    for i := pos, i < n, i := i+1 do
      case buf [i] of
        '\n' -> l := l + 1; c := 1
      | '\t' -> c := c + 8
      | _    -> c := c + 1
      esac
    od;
    
    matcherCreate (buf, pos + n, l, c)
  }

  fun matchString (s) {
    if s.length > rest ()
    then Fail (sprintf ("""%s"" expected at %d:%d", s, line, col))
    elif matchSubString (buf, s, pos) then Succ (shift (s.length), s) 
    else Fail (sprintf ("""%s"" expected at %d:%d", s, line, col))
    fi
  }

  fun matchRegexp (r) {
    local n;
    
    if (n := regexpMatch (r[0], buf, pos)) > 0
    then Succ (shift (n), substring (buf, pos, n))
    else Fail (sprintf ("%s expected at %d:%d", r[1], line, col))
    fi
  }

  fun eof () {
    rest () == 0
  }
  
  [show,
   eof,
   matchString,
   matchRegexp
  ]
}

fun show (m) {
  m [0] ()
}

fun endOf (m) {
  m [1] ()
}

fun matchString (m, s) {
  m [2] (s)
}

-- Matches against a regexp
fun matchRegexp (m, r) {
  m [3] (r)
}

-- Creates a fresh matcher from a string buffer
public fun matcherInit (buf) {
  matcherCreate (buf, 0, 1, 1)
}

local m = matcherInit ("   -- asdasdakm ,m.,msd .,m.,asd\n    \n\n abc");

local
  lident  = createRegexp ("[a-z][a-zA-Z_]*", "lowercase identifier"),
  uident  = createRegexp ("[A-Z][a-zA-Z_]*", "uppercase identifier"),
  ws      = createRegexp ("\\([ \t\n]\\|--[^\n]*\n\\)*", "whitespace"),
  str     = createRegexp ("""\([^""]\|""""\)*""", "string literal"),
  decimal = createRegexp ("[0-9]+", "decimal literal"),
  chr     = createRegexp ("'[^']'", "character literal");

fun token (s) {
  fun (m) {m.matchString (s)}
}


fun lid (m) {
  matchRegexp (m, lident)
}

fun uid (m) {
  matchRegexp (m, uident)
}

fun const (m) {
  matchRegexp (m, decimal)
}

infixl "@" before "*" (p, f) {
  fun (m) {    
    case p (m) of
      Succ (m, x) -> Succ (m, f (x))
    | err         -> err
    esac
  }
}

infixr "|>" after "!!" (l, r) {
  fun (m) {
    case l (m) of
      Succ (m, s) -> r (s) (m)
    | err         -> err
    esac
  }
}

infixr "||" after "|>" (l, r) {
  fun (m) {  
    case l (m) of
      s@Succ (_, _) -> s 
    | err           -> r (m)
    esac
  }
}

local expr = lid @ fun (s) {Lid (s)} || const @ fun (s) {Dec (s)},
      assn = lid |> fun (id) {token (":=") |> fun (s) {expr @ fun (e) {Assn (id, e)}}};

printf ("%s\n", case assn (matcherInit ("x:=3")) of Fail (err) -> err | Succ (_, s) -> s.string esac)
