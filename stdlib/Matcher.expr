-- (C) Dmitry Boulytchev, St. Petersburg State University, JetBrains Research, 2020
-- Matcher: simple string matching library.


-- Create a regular expression representation.
-- Arguments:
--    r    --- a string representation for regular expression (as per GNU regexp)
--    name --- a string describing the meaning of the expression in free form
--             (e.g. "identifier", "string constant", etc.), used for error
--             reporting
fun createRegexp (r, name) {
  return [regexp (r), name]
}

-- Create an immutable matcher.
-- Arguments:
--    buf --- a string to match in
--    pos --- an integer beginning position to match from
--    line, col --- line and column numbers
-- This function is internal, do not use it directly.
-- To initially create a matcher use initMatcher function (see below).
fun matcherCreate (buf, pos, line, col) {
  -- Shows a matcher in a readable form
  fun show () {
    return sprintf ("buf : %-40s\npos : %d\nline: %d\ncol : %d\n", buf, pos, line, col)
  }

  -- Calculates the number of remaining unmatched characters in the buffer
  fun rest () {
    return buf.length - pos
  }

  -- Moves the position pointer on given number of characters within one line (i.e. 
  fun shift (n) {
    return matcherCreate (buf, pos + n, line, col + n)
  }

  fun matchString (s) {
    return
      if s.length > rest ()
      then Fail (sprintf ("""%s"" expected at %d:%d", s, line, col))
      elif matchSubString (buf, s, pos) then Succ (shift (s.length), s) 
      else Fail (sprintf ("""%s"" expected at %d:%d", s, line, col))
      fi
  }

  fun matchRegexp (r) {
    local n;
    
    return
      if (n := regexpMatch (r[0], buf, pos)) > 0
      then Succ (shift (n), substring (buf, pos, n))
      else Fail (sprintf ("%s expected at %d:%d", r[1], line, col))
      fi
  }
  
  fun eof () {
    return rest () == 0
  }
  
  return [
     show,
     eof,
     matchString,
     matchRegexp
  ]
}

fun show (m) {
  return m [0] ()
}

fun eof (m) {
  return m [1] ()
}

fun matchString (m, s) {
  return m [2] (s)
}

fun matchRegexp (m, r) {
  return m [3] (r)
}

fun matcherInit (buf) {
  return matcherCreate (buf, 0, 1, 1)
}

--fun parse (a) {
 
--}

local m = matcherInit ("abc");

local ident = createRegexp ("[a-z][a-zA-Z_]*", "identifier");
local ws    = createRegexp ("[ \n\t]+", "whitespace");
local str   = createRegexp ("""\([^""]\|""""\)*""", "string literal");

printf ("ident: %s\n", case m.matchRegexp (ident) of Succ (m, s) -> "(" ++ m.show  ++ ", " ++ s ++ ")" | Fail (err) -> err.string esac)
