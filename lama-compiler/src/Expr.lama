-- Expression evaluator

import List;
import Array;
import State;
import World;
import Lexer;
import Parser;
import Fun;
import Builtins;

-- As association map which maps "\otimes" into "\oplus"
var ops = {
  ["+" , infix + ],
  ["-" , infix - ],
  ["*" , infix * ],
  ["/" , infix / ],
  ["%" , infix % ],
  ["==", infix ==],
  ["!=", infix !=],
  ["<" , infix < ],
  ["<=", infix <=],
  [">" , infix > ],
  [">=", infix >=],
  ["&&", infix &&],
  ["!!", infix !!]
};

-- The evaluator for infix operators: takes an operator as a string
-- and two operand values, and returns the result
public fun evalOp (op, l, r) {
  case assoc (ops, op) of
    Some (f) -> f (l, r)
  esac
}

-- Evaluates an expression "expr" in a configuration "c".
-- A configuration is a pair of a state "s" and a world "w".
-- Returns a final configuration (if any)
--
-- A expression is represented by a data structure of the following shape:
--
-- expr = Assn    (expr, expr)              |
--        Set     (string, expr)            |
--        Seq     (expr, expr)              |
--        Skip                              |
--        if      (expr, expr, expr)        |
--        While   (expr, expr)              |
--        Repeat  (expr, expr)              |
--        Var     (string)                  |
--        Ref     (string)                  |
--        Const   (int)                     |
--        Binop   (string, expr, expr)      |
--        Call    (string, expr list, loc)  |
--        Case    (expr, branch list, loc)  |
--        Ignore  (expr)                    |
--        String  (string)                  |
--        Array   (expr list)               |
--        Elem    (expr, expr)              |
--        ElemRef (expr, expr)              |
--        Builtin (string, expr list)

-- Helper function: adds a bunch of regular variables current scope
fun addNames (state, names) {
  foldl (fun (s, name) {s.addName (name, Val (0))}, state, names)
}

-- Helper function: adds a function in current scope
fun addFunction (state, name, args, body) {
  state.addName (name, Fun (args, body, state.getLevel))
}
                                        
-- Evaluates a list of expressions, properly threading a configurations.
-- Returns the final configuration and the list of values
fun evalList (c, exprs) {
  case foldl (fun ([c, vals], e) {
                case eval (c, e) of
                  [c, value] -> [c, value : vals]
               esac
              },
              [c, {}],
              exprs) of
    [c, vals] -> [c, reverse (vals)]
  esac
}

(* Assignment
fun eval (c@[s, w], expr) {
  failure ("evalExpr not implemented\n")
}
   End *)

(* Implementation *)
fun eval (c@[s, w], expr) {
  case expr of
    Scope (ds, e)     -> case eval ([foldl (fun (s, def) {
                                              case def of
                                                Var (ds)               -> addNames (s, ds)
                                              | Val (ds)               -> addNames (s, ds)
                                              | Fun (name, args, body) -> addFunction (s, name, args, body)
                                              esac
                                            }, s.enterScope, ds),
                                     w],
                                    e) of
                            [[s, w], vs] -> [[s.leaveScope, w], vs]
                         esac
                         
  | Case  (e, brs, [line, col]) -> case eval (c, Var (e)) of
                            [c, v] ->  fun matchedBy (p, v) {
                                         case p of
                                           Wildcard         -> true
                                         | Named    (_, p)  -> matchedBy (p, v)
                                         | Const    (n)     -> case v of #val -> n == v | _ -> false esac
                                         | String   (s)     -> case v of #str -> compare (s, v) == 0 | _ -> false esac
                                         | Sexp     (c, ps) -> case v of
                                                                 Sexp (cc, vs) ->
                                                                   if compare (c, cc) == 0 && ps.size == vs.length
                                                                   then fst $ foldl (fun ([acc, i], p) {[acc && matchedBy (p, vs[i]), i+1]}, [true, 0], ps)
                                                                   fi
                                                               | _  -> false
                                                               esac
                                         | Array    (ps)    -> case v of
                                                                 #array ->
                                                                   if v.length == ps.size
                                                                   then fst $ foldl (fun ([acc, i], p) {[acc && matchedBy (p, v[i]), i+1]}, [true, 0], ps)
                                                                   else false
                                                                   fi
                                                               | _ -> false
                                                               esac
                                         esac
                                      }
                                      
                                      fix (fun (rec) {
                                             fun (brs) {
                                               case brs of
                                                 {}          -> failure ("Match failure in interpreter for %s at %d:%d\n", v.string, line, col)
                                               | [p, e] : ps ->
                                                  if matchedBy (p, v)
                                                  then eval (c, e)
                                                  else rec (ps)
                                                  fi
                                               esac
                                             }
                                          }) (brs)
                         esac
  
  | Sexp    (s, args) -> case evalList (c, args) of
                           [c, vals] -> [c, Sexp (s, listArray $ vals)]
                         esac                      
  | Builtin (f, args) -> case evalList (c, args) of
                           [[s, w], vals] -> case evalBuiltin (f, vals, w) of
                                              [a, w] -> [[s, w], a]
                                             esac
                         esac
  | String (s)     -> [c, s]
  | Array  (es)    -> case evalList (c, es) of
                        [c, vals] -> [c, listArray (vals)]
                      esac
  | Elem   (e, i)  -> case evalList (c, {e, i}) of
                        [c, {ev@#array, iv@#val}] -> [c, ev[iv]]
                      | [c, {ev@#str  , iv@#val}] -> [c, ev[iv]]
                      | [c, {Sexp (_, ev), iv@#val}] -> [c, ev[iv]]
                      esac
  | Set   (x, e)   -> case eval (c, e) of
                        [[s, w], v] -> [[s <- [x, Val (v)], w], v]
                      esac
  | Assn  (x, e)   -> case evalList (c, {x, e}) of
                        [[s, w], {Ref (x), v}] ->
                           [[s <- [x, Val (v)], w], v]
                      | [c, {ElemRef (w@#array, i@#val), v}] ->
                           w[i] := v;
                           [c, v]
                      | [c, {ElemRef (w@#str, i@#val), v}] ->
                           w[i] := v;
                           [c, v]
                      | [c, {ElemRef (Sexp (_, w), i@#val), v}] ->
                           w[i] := v;
                           [c, v]
                      esac
  
  | Seq   (s1, s2) -> eval (eval (c, s1).fst, s2)
    
  | Skip           -> [c, 0]
  | If (e, s1, s2) -> case eval (c, e) of
                        [c, 0] -> eval (c, s2)
                      | [c, _] -> eval (c, s1)
                      esac
  | While (e, b)   -> case eval (c, e) of
                        x@[c, 0] -> x
                      | [c, _]   -> eval (eval (c, b).fst, expr)                      
                      esac
  | Repeat (b, e)  -> case eval (c, b) of
                        [c, _] -> case eval (c, e) of
                                    [c, 0] -> eval (c, expr)
                                  | [c, _] -> [c, 0]
                                  esac
                      esac
  | Var   (x)        -> [c, case s.lookup (x) of
                              Val (x)       -> x
			    | Fun (a, b, l) -> Closure (a, b, s.toEnv (l))
			    esac]
  | ElemRef (a, i)   -> case evalList (c, {a, i}) of
                          [c, {a, i}] -> [c, ElemRef (a, i)]
                        esac
  | Ref   (x)        -> s.lookup (x); [c, Ref (x)]
  | Const (n)        -> [c, n]
  | Binop (op, l, r) -> case evalList (c, {l, r}) of
                          [c, {x, y}] -> [c, evalOp (op, x, y)]
                        esac  
  | Ignore (e)       -> case eval (c, e) of
                          [c, _] -> [c, 0]
                        esac			
  | Lambda (a, b)    -> [c, Closure (a, b, s.toEnv (s.getLevel))]  
  | Call  (f, args, loc) ->
                        case eval (c, f) of
                          [c, Closure (fargs, body, env)] -> 
                            if fargs.size != args.size
                               then error (sprintf ("wrong number of actual parameters in function call"), loc)
                            fi;
                            case evalList (c, args) of
                              [[s, w], vals] ->
                                case body of
                                  External (name) -> case evalBuiltin (name, vals, w) of
                                                       [a, w] -> [[s, w], a]
                                                     esac
                                | _ ->
                                  var state = foldl (fun (s, [name, value]) {s.addName (name, Val (value))},
                                                     s.enterFunction (env),
                                                     zip (fargs, vals));
                                  case eval ([state, w], body) of
                                    [[state, w], value] -> [[s.leaveFunction (state.getGlobal), w], value] 
                                  esac
                                esac
                            esac
                       esac 
  esac
}
(* End *)

-- Evaluates a program with a given input and returns an output
public fun evalExpr (input, expr) {
  case eval ([emptyState ().enterScope
                           .addFunction ("read", {}, External ("read"))
                           .addFunction ("write", {"a"}, External ("write")),
              createWorld (input)], expr) of
    [c, _] -> c.snd.getOutput
  esac
}